% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clusterSNNGraph.R
\name{clusterSNNGraph}
\alias{clusterSNNGraph}
\alias{clusterSNNGraph.default}
\alias{clusterSNNGraph.SingleCellExperiment}
\alias{clusterSNNGraph.Seurat}
\title{Graph-based clustering with \code{scrapper}}
\usage{
clusterSNNGraph(object, ...)

\method{clusterSNNGraph}{default}(
  object,
  n_neighbors = 10L,
  method = NULL,
  ...,
  scheme = NULL,
  BNPARAM = AnnoyParam(),
  threads = NULL
)

\method{clusterSNNGraph}{SingleCellExperiment}(object, ..., dimred = "PCA", n_dimred = NULL, assay = NULL)

\method{clusterSNNGraph}{Seurat}(
  object,
  ...,
  dimred = "PCA",
  n_dimred = NULL,
  assay = NULL,
  layer = NULL
)
}
\arguments{
\item{object}{A \code{\link[igraph:make_graph]{graph}} object.}

\item{...}{Additional arguments passed on to \code{\link[=clusterGraph]{clusterGraph()}}.}

\item{n_neighbors}{Integer scalar specifying the number of neighbors to use
to construct the graph.}

\item{method}{String specifying the community detection method to use.
Options are multi-level (\code{"multilevel"}/\code{"louvain"}), Walktrap (\code{"walktrap"})
or Leiden (\code{"leiden"}) (default).}

\item{scheme}{String specifying the weighting scheme to use for constructing
the SNN graph. This can be \code{"ranked"} (default), \code{"jaccard"} or \code{"number"}.}

\item{BNPARAM}{A \link[BiocNeighbors]{BiocNeighborParam} object specifying the algorithm to use.
Only used if \code{x} is not a list of existing nearest-neighbor search results.}

\item{threads}{Integer scalar specifying the number of threads to use. If
\code{NULL}, all detected threads will be used. See
\code{\link[parallel:detectCores]{detectCores}}.}

\item{dimred}{String or integer scalar specifying the existing dimensionality
reduction results to use.}

\item{n_dimred}{Integer scalar or vector specifying the dimensions to use if
dimred is specified.}

\item{assay}{Integer scalar or string indicating which assay of x
contains the expression values.}

\item{layer}{Name of the layer to get from the assay data.}
}
\value{
An integer vector with cluster assignments for each cell. Each method
may also return additional attributes.
\itemize{
\item For method=\code{"multilevel"}/\code{"louvain"}, we have:
\itemize{
\item \code{levels}, a list of integer vectors with cluster assignments for each
cell at each level. Assignments are sorted by decreasing resolution (i.e.,
fewer, larger clusters).
\item \code{modularity}, a numeric vector containing the modularity of each level.
\item \code{best}, the level with the lowest modularity.
}
\item For method=\code{"leiden"}, we have:
\itemize{
\item \code{quality}: a numeric scalar containing the quality of the clustering
(either the modularity or a related score).
}
\item For method=\code{"walktrap"}, we have:
\itemize{
\item \code{merges}: an integer matrix specifying how the clusters were merged to
obtain membership. Each row corresponds to a merge step and contains the
IDs of the temporary clusters (not the same as those in membership).
\item \code{modularity}: a numeric vector containing the modularity before and
after each merge step.
}
}
}
\description{
Graph-based clustering with \code{scrapper}
}
\seealso{
\itemize{
\item \code{\link[scrapper:buildSnnGraph]{buildSnnGraph}}
\item \code{\link[igraph:cluster_louvain]{cluster_louvain}}
\item \code{\link[igraph:cluster_leiden]{cluster_leiden}}
\item \code{\link[igraph:cluster_walktrap]{cluster_walktrap}}
}
}
